## 1장 깨끗한 코드

깨끗한 코드란?

- 효율이 좋은 코드 

- 속도, CPU 자원을 낭비하지 않는 코드
- 한가지에 집중한 코드, 각 함수와 클래스와 모듈이 오염되지 않은 코드

- 오류처리, 메모리 누수, 경쟁 상태, 명명법 고려
- 명쾌한 추상화, 단순한 제어문
- 다른 사람이 고치기 쉬운 코드
- 단위 테스트 케이스와 인수 테스트 케이스 존재
- 중복이 없는 코드
- 클래스, 메서드, 함수 등을 최대한 줄인 코드 



## 2장 의미 있는 이름

1. 의도를 분명히 밝혀라

- 의도가 드러나는 이름 사용	

2. 그릇된 정보는 피하라

- 널리 쓰이는 의미가 있는 단어를 다른 의미로 사용하면 안 됨
- 여러 계정을 그룹으로 묶을 때 accountList (x) accountGroup, Accounts (o)
  - List는 특수한 의미, 실제 List가 아니면 사용하지 말기
- 유사한 개념은 유사한 표기법 사용

3. 의미있게 구분하라

- 연속적인 숫자나 불용어를 덧붙인 이름 쓰지 말기, 저자의 의도가 드러나지 않음
- 함수 인수 이름으로 source와 destination 사용 시 코드 읽기가 쉬워짐
  - ex) a1, a2, a3 / Product**Info**, Product**Data** / accountData, account
- 변수 이름에 variable 쓰지말기
- 표 이름에 table 쓰지말기
- 읽는 사람이 차이를 알도록 이름을 짓기

4. 발음하기 쉬운 이름을 사용하라

5. 검색하기 쉬운 이름을 사용하라

   - 긴 이름 >> 짧은 이름
   - 검색하기 쉬운 이름 >> 상수
   - 이름 길이 ∝ 범위크기

6. 인코딩을 피해라

   - 헝가리 표기법 X
     - 변수 이름에 타입을 인코딩
     - 변수, 함수, 클래스 이름이나 타입을 바꾸기가 어려워지고 읽기 어려워짐
   - 접두어 X

7. 기억력을 자랑하지 마라

   - 클래스 이름

     - 명사나 명사구가 적합

       ex) Customer, WikiPage, Account (o)

       ​		Manager, Data, Info (x)

   - 메서드 이름

     - 동사나 동사구가 적합

       ex) postPayment, deletePage, save (o)

     - 접근자, 변경자, 조건자는 get, set, is 붙이기

8. 기발한 이름은 피해라

9. 한 개념에 한 단어를 사용하라

   - 메서드 이름은 독자적이고 일관적

     ex) DeviceManager, ProtocolController (x , 통일하기)

10. 말장난을 하지마라

    - 기존에 add 메서드는 기존 값에 두 개를 더하거나 이어서 새로운 값을 만든다고 가정
    - 새로 작성하는 메서드에선 집합에 값 하나를 추가시 insert, append 가 적당

11. 의미있는 맥락을 추가하라

    - firstName, lastName, state (x)
    - addrFirstName, addrLastName, addrState (x)

12. 불필요한 맥락을 없애라

    - 의미가 분명한 경우에 한해서 짧은 이름 >> 긴이름

      



## 3장 함수

1. 작게 만들어라

   - **if문, while문 등에 들어가는 블록은 한 줄이어야 함**

2. 한 가지만 해라

   -  추상화 수준이 하나인 단계만 수행하기
   -  함수 내 모든 문장이 추상화 수준이 비슷해야함
   -  switch문 사용시 추상 팩토리에 숨겨서 사용

3. 서술적인 이름을 사용해라

   - 모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용

4. 함수 인수

   - 이상적인 인수는 0항

   - 1개 ㄱㅊ, 2개 복잡, 3개 이상은 에바

   - 인수가 2-3개 필요하면 독자적인 클래스 변수로 선언해라

   - 출력 인수가 입력 인수보다 이해 어려움

   - 플래그 인수

     - 추함, 함수로 부울 값 넘기는 관례는 끔찍 -> 함수가 여러 개를 처리하게 되니까

   - 함수와 인수 쌍을 동사/명사 쌍을 이루면 좋음

     ex) witeField(name)

   - 함수 이름에 인수 키워드 추가

     ex) assertExpectedEqualsActual(expected, actual)

5. 부수효과를 일으키지마라

   예시로 checkPassword 라는 이름을 가진 함수가 그 안에선 세션을 초기화 하면 안 됨

   의도치 않게 중요한 정보가 날아갈 수 있음

   checkPasswordAndInitializeSession 이라는 이름이 훨씬 좋음(but 함수가 1가지만 한다는 규칙은 위반)

6. 출력 인수 피하기

   - 함수에서 상태를 변경해야 한다면 함수가 속한 객체 상태를 변경하는 방식을 선택해라

7. 명령과 조회를 분리하라

   - 함수는 수행 or 응답 둘 중 하나만 해야함

8. 오류 코드보다 예외를 사용하라

   - try catch 블록 별도 함수로 뽑아내는게 좋음
   - 오류 처리 함수는 오류 처리만 해야 함(1가지 함수는 1가지 작업만)
   - 오류 코드 대신 예외 사용하면 새 예외는 Exception 클랭스에서 파생, 재컴파일/재배치 없이도 새 예외 클래스 추가 가능

9. 모든 함수와 모든 블록에 입구와 출구가 하나만 존재해야 함

   - return 문이 하나여야 함

   - 루프 안에서 break, continue 사용하면 안 됨, **goto 절대 안 됨**

   - but 작은 함수에선 break continue return 여러 차례 사용해도 됨

     



## 4장 주석

### 좋은주석	

**가장 좋은 주석은 주석을 달지 않을 방법을 찾아낸 주석이다**

- 주석은 오래될수록 코드에서 멀어짐
- **주석말고 코드로 의도를 표현해라**

1. 법적인 코드 주석

   - 계약조건, 법적인 정보

2. 정보를 제공하는 주석

   - 가능하다면 함수 이름에 정보를 담는 편이 더 좋음

3. 의도를 설명하는 주석

4. 의미를 명로하게 밝히는 주석

   - 인수나 반환값이 표준 라이브러리나 변경하지 못하는 코드에 속하면 의미를 명료하게 밝히는 주석이 유용
   - 주석은 올바른지 검증하기 어렵기 때문에 주의!

5. 결과를 경고하는 주석

   - 다른 프로그래머에게 경고

     ex) 특정 테스트 케이스를 꺼야할 때 

   - 구체적인 설명은 @Ignore 속성에 문자열로 넣어줌

6. TODO 주석

   - 필요하지만 당장 구현하기 어려운 업무 기술
   - but 주기적으로 점검해서 없애도 괜찮은 TODO는 삭제하기

7. 중요성을 강조하는 주석

   - 자칫 대수지 않게 여겨질 주어질 무언가의 중요성 강조



### 나쁜주석

1. 특별한 이유없이 의무감으로 마지못해 단 주석
2. 이해가 안 되어 다른 모듈까지 뒤져야 하는 주석
3. 같은 이야기를 중복하는 주석
   - 같은 코드 내용을 그대로 중복
4. **함수나 변수로 표현할 수 있다면 주석을 달지마라**
5. **특정 위치를 표시하려는 주석**
   - 반드시 필요할 때만 드물게 사용하기, 배너를 남용시 무시하게 됨
6. **닫는 괄호에 다는 주석**
   - 닫는 괄호에 주석을 달지말고 함수를 줄여라
7. **저자를 표시하는 주석**
   - 소스 코드 관리 시스템에 저장하는 편이 좋음
8. **주석으로 처리된 코드**
   - 다른 사람들이 지우기 주저함, 그냥 코드를 삭제해라
9. HTML 주석
   - IDE 조차 읽기 어려움
10. 전역정보
    - 근처에 있는 코드에 대해서만 주석 기술, 시스템의 전반적인 정보를 기술하지 말기





## 5장 형식 맞추기

1. 적절한 행 길이 유지

   - 200줄 정도인 파일로도 커다란 시스템을 구축할 수 있음
   - 되도록 세로 길이 줄이기
   - 소스파일 이름은 간단하면서도 설명이 가능하게 짓기
   - 소스 파일 첫부분은 고차원 개념과 알고리즘을 설명, 아래로 내려갈수록 세세하게 묘사
   - 생각 사이는 빈 행을 넣어 분리해서 가독성⬆️
   - 서로 밀접한 개념은 세로로 가까이 두기
   - **서로 밀접한 개념은 한 파일에 속해야 마땅, protected 변수를 피해야하는 이유 중 하나**
   - 변수 : 사용하는 위치에 최대한 가까이 선언 / 지역 변수 : 각 함수 맨 처음에 선언 / 인스턴스. 변수 : 클래스 맨 처음에 선언
   - 호출하는 함수 먼저, 호출되는 함수 나중에 배치

   

2. 가로 형식 맞추기

   - 45자 정도 (20~60자 사이)가 적당, 저자는 120자 정도로 행 길이 제한

   - 할당 연사자는 앞뒤에 공백으로 강조

   - 연산자 우선순위 강조를 위해서 공백 사용

     - 승수 사이는 공백 X
     - 항 사이에는 공백 O

   - 들여쓰기

     - 클래스 정의처럼 파일 수준인 문장 : 들여쓰지 않음
     - 메서드 : 클래스보다 한 수준 들여씀
     - 메서드 코드 : 메서드 선언보다 한 수준 들여씀
     - 블록코드 : 블록을 포함하는 코드보다 한 수준 들여씀

   - 빈 while문이나 for문에서 세미콜론은 새 행에다 제대로 들여써주기

     

## 6장 객체와 자료구조

1. 자료 추상화

   - 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스

   - 자료를 세세하게 공개하기 보다는 추상적인 개념으로 표현하는 편이 좋음

   - 아무생각 없이 조회/설정 함수를 추가하는 방법이 가장 나쁨

2. 자료/객체 비대칭

   - 객체 : 자료 숨김(추상화), 함수 공개
   - 자료구조: 자료 공개, 별다른 함수 제공 X
   - 객체와 자료구조는 근본적으로 양분
   - 절차적인 코드 : 새 함수 추가 쉬움, 새로운 자료구조 추가 어려움
   - 객체지향 코드 : 새 클래스 추가 쉬움, 새로운 함수 추가 어려움

3. 디미터 법칙

   - 모듈은 자신이 조작하는 객체의 속사정을 몰라야 함
   - 기차충돌 : 여러 객체가 한줄로 이어진 구조, 나누는게 좋음
   - 잡종구조
     - 절반은 객체, 절반은 자료구조
     - 되도록 피하는 편이 좋음

4. 자료 전달 객체 DTO

   - 공개 변수만 있고 함수가 없는 클래스
   - 활성 레코드 
     - DTO의 특수한 형태
     - 비공개 변수에 조회/설정 함수가 있는 자료 구조
     - 탐색 함수도 제공
     - 자료구조로 취급

5. 결론

   - 객체는 동작을 공개하고 자료는 숨김
   - 자료구조는 별다른 동작 없이 자료 노출
   - 시스템 구현 시 새로운 자료 타입을 추가하는 유연성 필요 -> 객체 적합
   - 새로운 동작을 추가하는 유연성 필요 -> 자료구조, 절차적인 코드 적합



## 7장 오류 처리

1. 오류코드보단 예외를 사용하라
   - 오류 발생 시 예외를 던지면 호출자 코드가 깔끔해짐
2. try catch finally 문부터 작성하라
   - try 블록에서 무슨 일이 생기든지 catch 블록은 프로그램 상태를 일관성 있게 유지해야함
3. 미확인 예외를 사용하라
   - 확인된 예외는 OCP(Open Closed Principle) 를 위반
   - throws 경로에 위치하는 모든 함수가 최하위 함수에서 던지는 예외를 알아야 하므로 캡슐화가 깨짐
   - 일반적인 애플리케이션은 의존성이라는 비용 > 이익
4. 예외에 의미를 제공하라
   - 오류 메시지에 정볼르 담아 예외와 함께 던짐
   - 실패한 연산 이름과 실패 유형 언급
5. 호출자를 고려해 예외 클래스를 정의하라
   - 예외 유형과 무관하게 예외 대응 방식은 거의 동일
   - 호출하는 라이브러리 API를 감싸면서 예외 유형 하나를 반환하면 됨
   - 외부 API 사용 시 감싸기 기법이 최선
6. null을 반환, 전달하지 마라



## 8장 경계

외부 코드를 우리 코드에 깔끔하게 통합해야만 함

소프트웨어 경계를 깔끔하게 처리하는 기법을 보자



1. 외부코드 사용하기

   경계 인터페이스를 이용할 때는 이를 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의

2. 경계 살피고 익히기

   - 학습 테스트 : 외부 코드를 익힐 때 간단한 테스트 케이스를 작성하기
   - 프로그램에서 사용하려는 방식대로 외부 API를 호출

3. 결론

   - 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리
   - 새로운 클래스로 경계를 감싸거나 ADAPTER 패턴을 사용해 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환하자



## 9장 단위 테스트

TDD(Test Driven Development)

1. TDD 법칙 세 가지

   1. 실패하는 단위 테스트 작성 시까지 실제 코드 작성 X
   2. 컴파일은 실패하지 않으면서 실행이 실패하는 단위 테스트 작성
   3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드 작성

2. 깨끗한 테스트 코드 유지

   - 실제 코드가 진화하면 테스트 코드도 변해야 함
   - 테스트 코드는 실제 코드 못지않게 깨끗하게 짜져야 함
   - 테스트는 유연성, 유지보수성, 재사용성을 제공함
     - 테스트 케이스가 있으면 변경이 쉬워지기 때문

3. 깨끗한 테스트 코드란?

   - **가독성**이 실제코드보다 더더욱 중요
   - 도메인에 특화된 테스트 언어
   - 실제 코드만큼 단순하고, 간결해야하지만 효율적일 필요는 없음
   - 테스트 환경은 자원이 제한적일 가능성이 낮음
   - 실제 환경에서는 안 되지만 테스트 환경에서는 전혀 문제 없는 방식이 있음 (메모리나 CPU 효율과 관련된 경우)

4. 테스트 당 assert 하나

   - assert 문 개수는 최대한 줄여야 좋음
   - 테스트 함수마다 한 개념만 테스트

5. FIRST

   1. 빠르게 :  테스트는 빨라야함
   2. 독립적으로 : 어떤 순서로 테스트를 실행해도 괜찮아야 함
   3. 반복가능하게 : 어떤 환경에서도 반복 가능해야함, 테스트가 돌아가지 않는 환경이 하나라도 있으면 안 됨
   4. 자가 검증하는 : 부울 값으로 결과를 내야 함
   5. 적시에 : 단위 테스트는 테스트 하려는 실제 코드를 구현하기 직전에 구현

6. 결론

   테스트 코드는 지속적으로 깨끗하고, 표현력을 높이고, 간결하게 정리



## 10장 클래스

1. 클래스 체계
   1. 변수 목록
      1. 정적 공개 상수
      2. 정적 비공개 변수
      3. 비공개 인스턴스 변수
   2. 공개 함수
   3. 비공개 함수(자신을 호출하는 공개 함수 직후)
2. 클래스는 작아야 한다
   - 클래스 크기의 척도는 맡은 책임
   - 클래스 이름은 해당 클래스 책임을 기술
   - 단일 책임 원칙 SRP
     - 클래스는 책임 즉 변경할 이유가 하나여야 함
   - 큰 클래스 몇개보다 작은 클래스 여럿으로 이뤄진 시스템이 바람직
   - 응집도
     - 응집도가 높다 == 클래스에 속한 메서드와 변수가 서로 의존한다
     - 클래스는 인스턴스 변수 수가 작아야 함
     - 메서드가 변수를 더 많이 사용할수록 메서드와 클래스 응집도⬆️
3. 변경하기 쉬운 클래스
   - 클래스 일부에서만 사용되는 비공개 메서드는 개선해야 함
   - OCP(Open Closed Principle) : 클래스는 확장에 개방적, 수정에 폐쇄적
   - 상세한 구현에 의존하는 클라이언트 클래스는 구현이 바뀌면 위험함
   - 인터페이스와 추상 클래스를 사용해 구현에 미치는 영향 격리



## 11장 시스템

1. 시스템 제작과 시스템 사용을 분리해라
   - 초기화 지연(혹은 계산 지연)
     - 장점
       - 실제로 필요할 때까지 객체 생성 X => 불필요한 부하가 걸리지 않음, 애플리케이션 시작 시간 빨라짐
       - 어떤 경우에도 null 포인터를 반환하지 않음
     - 단점
       - 의존성을 해결하지 않으면 컴파일이 안 됨
       - 테스트 전용 객체를 service 필드에 할당해야 함
       - 단일 책임 원칙을 깸
   - main 분리
     - 생성과 관련된 코드는 모두 main 이나 main이 호출하는 모듈로 옮김, 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정
     - 애플리케이션은 main이나 객체가 생성되는 과정을 전혀 모름
   - 팩토리
     - 객체가 생성되는 시점을 애플리케이션이 결정할 필요가 생겼을 때 ABSTRACT FACTORY 패턴 사용
     - 애프리케이션이 객체가 생성되는 구체적인 방법은 모르지만, 인스턴스가 생성되는 시점을 통제 가능
   - 의존성 주입
     - IoC 기법(제어 역전)을 의존성 관리에 적용한 메커니즘
     - 제어 역전에서는 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 넘김
     - 새로운 객체는 넘겨 받은 책임만 맡으므로 SRP 지킴
     - 책임질 메커니즘으로 main 루틴이나 특수 컨테이너 사용
     - 진정한 의존성 주입은 클래스는 수동적, 호출하는 객체가 의존성을 능동적으로 해결
2. 자바 프록시
   - 단순한 상황에 적합
   - 개별 객체나 클래스에서 메서드 호출을 감싸는 경우
   - 단점 : 코드의 양과 크기
   - 프록시를 사용하면 깨끗한 코드 작성 어려움, 프록시는 시스템 단위로 실행 지점을 명시하는 메커니즘 제공 X
3. 순수 자바 AOP 프레임워크
   - 대부분의 프록시 코드는 판박이라 도구로 자동화 가능
   - 여러 자바 프레임워크는 내부적으로 프록시 사용
   - POJO 는 순수하게 도메인에 초점을 맞춤, 엔터프라이즈 프레임워크에 의존하지 않음 => 테스트가 개념적으로 쉽고 간단, 사용자 스토리 올바로 구현하기 쉬움, 미래 스토리에 맞춰 코드 보수 개선 편함
   - 애너테이션에 들어있는 영속성 정보 XML 배치 기술자로 옮겨도 OK
   - EJB2에 비해 문제 발생 가능성 적음
4. AspectJ 관점
   - 언어 차원에서 관점을 모듈화 구성으로 지원하는 자바 언어 확장
   - 관점을 분리하는 강력하고 풍부한 도구 집합을 제공, but 새 도구를 사용하고 새 언어 문법과 사용법을 익혀야 함
5. 테스트 주도 시스템 아키텍처 구축
   - 코드수준에서 아키텍처 관심사를 분리할 수 있다면 진정한 테스트 주도 아키텍처 구축이 가능함
   - 결과물을 재빨리 출시 후 기반 구조를 추가하며 조금씩 확장해도 OK
   - 최선의 시스템 구조는 POJO 객체로 구현되는 모듈화된 관심사 영역으로 구성됨
6. 표준에 집착하지 말아라
7. 시스템은 도메인 특화 언어가 필요
   - DSL(Domain Specific Language) : 스크립트 언어나 표준 언어로 구현한 API
   - 좋은 DSL은 도메인 개념과 개념을 구현한 코드 사이에 존재하는 의사소통 간극을 줄여줌
8. 결론
   - 깨끗하지 못한 아키텍처는 도메인 논리를 흐리고 제품 품질을 낮춤
   - 모든 추상화 단계에서 의도는 명확히 표현되어야 함

