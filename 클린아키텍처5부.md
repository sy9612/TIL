# 15장 아케텍처란

- 소프트웨어 시스템의 아키텍처
    
    시스템을 구축했던 사람들이 만들어낸 시스템의 형태
    
- 아키텍처의 주된 목적
    
    시스템의 생명주기를 지원하는 것
    
- 아키텍처의 궁극적인 목표
    
    시스템의 수명과 관련된 비용은 최소화하고，프로그래머의 생산성은 최대화
    
- 배포
    
    배포 비용이 높을수록 시스템의 유용성은 떨어짐
    
    MSA
    
    컴포 넌트 경계가 매우 뚜렷해지고 인터페이스가 대체로 안정화
    
    but, 배포할 시기가 되 면 위협적일 만큼 늘어난 수많은 마이크로서비스를 발견하게 될지도
    
- 운영
    
    아키텍처가 시스템 운영에 미치는 영향은 개발，배포，유지보수에 미치는 영향보다는 덜 극적
    
    운영에서 겪는 대다수의 어려움은 단순히 하드웨어를 더 투입해서 해결가능
    
    좋은 소프트웨어 아키텍처는 시스템을 운영하는 데 필요한 요구도 알려줌
    
- 유지보수
    
    유지보수의 가장 큰 비용은 **탐사**와 이로 인한 **위험부담**
    
    탐사: 새로운 기능을 추가하거나 결함을 수정할 때，소 프트웨어를 파헤쳐서 어디를 고치는 게 최선인지, 그리고 어떤 전략을 쓰는 게 최적일지를 결정할 때 드는 비용
    
    변경사항을 반영할 때 의도 치 않은 결함이 발생할 가능성은 항상 존재
    
    시스템을 컴포넌트로 분리하고 안정된 인터페이스를 두어 서로 격리
    
- 소프트웨어 가치
    1. 행위적 가치
    2. 구조적 가치
        
        소프트웨어를 부드럽게 만드는 것
        
    
    소프트웨어를 부드럽게 유지하는 방법
    
    선택사항을 가능한 한 많이 그리고 가능한 한 오랫동안 열어 두는 것
    
    소프트웨어 시스템 구성요소
    
    1.  정책 
        
        모든 업무 규칙과 업무 절차를 구체화
        
    2. 세부사항
        
        정책과 소통할 때 필요한 요 소지만，정책이 가진 행위에는 조금도 영향을 미치지 않음
        
- 아키텍트의 목표
    
    시스템에서 정책을 가장 핵심적인 요소로 식별
    
    세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축
    
    좋은 아키텍트는 결정되지 않은 사항의 수를 최대화
    
- 결론
    
    좋은 아키텍트는 세부사항 을 정책으로부터 신중하게 가려내고，정책이 세부사항과 결합되지 않도록 엄격하게 분리
    
    좋은 아키텍트는 세부사항에 대한 결정을 가능한 한 오랫동안 미룰 수 있는 방향으로 정책을 설계
    

# 16장 독립성

- 유스케이스
    
    시스템의 아키텍처는 시스템의 의도를 지원
    
    아키텍처에서도 유스케이스 가 최우선
    
    아키텍처는 반드시 유스케이스를 지원
    
    행위를 명확히 하고 외부로 드러내며 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만드는 것
    
- 콘웨이의 법칙
    
    의사소통 구조와 동일한 구조의 설계를 만들어 낼 것
    
- 배포
    
    아키텍처는 배포 용이성을 결정하는 데 중요한 역할
    
    좋은 아키텍처라면 시스템이 빌드된 후 즉각 배포할 수 있도록 지원
    
    시스템을 컴포넌트 단위로 적절하게 분할하고 격리
    
    마스터 컴포넌트는 시스템 전체를 하나로 묶고, 각 컴포넌트를 올 바르게 구동하고 통합하고 관리
    
- 계층 결합 분리
    
    아키텍트는 단일 책임 원칙과 공통 폐쇄 원칙을 적용
    
    의도의 맥락에 따라 다른 이유로 변경되는 것들은 분리, 동일한 이유로 변경되는 것들은 묶음
    
    유스케이스는 시스템을 분할하는 매우 자연스러운 방법
    
    각 유스케이스가 UI와 데이터베이스의 서로 다른 관점을 사용하여 새로운 유스케이스 추가에도 기존 유스케이스 영향X
    
- 배포독립성
    
    유스케이스와 계층의 결합이 분리되면 배포 측면에서도 고도의 유연성이 생김
    
- 중복
    
    두 유스케이스의 화면 구조가 매우 비슷하다고 가정
    
    우발적 중복일 가능성이 높음
    
    이러한 이유로, 해당 코드를 통합하지 않도록 유의
    
    중복이 진짜 중복인지 확인
    
- 결론
    
    시스템의 결합 분리 모드는 시간이 지나면서 바뀌기 쉬우며，뛰어난 아키텍트라면 이러한 변경을 예측하여 큰 무리 없이 반영 할 수 있도록 만들어야 함
    

# 17장 경계

경계는 소프트웨어 요소를 서로 분리

좋은 시스템 아키텍처란 이러한 결정이 부수적이며 결정을 연기할 수 있는 아키텍처

결정에 따른 영향이 크지 않게 만듦

기본뼈대만갖춘웹 서버는 단순한 단일 소프트웨어이기에 구현이 간단

어떤 웹 프레임워크를 사용할지에 대한 결정을 훨씬 나중으로 연기할 수 있도록 해줌

경계선을 긋는 행위는 결정을 늦추고 연기하는 데 도움

- 결론

경계선을 그리려면 먼저 시스템을 컴포넌트 단위 로 분할해야 함

일부 컴포넌트는 핵심업무 규칙에 해당

나머지는 플러그인으로 필수기능 포함

컴포넌트사이의 화살표가 핵심 업무를 향하도록 컴포넌트 소스 배치

의존성 화살표는 저수준 세부사항에서 고수준의 추상화를 향하도록 배치

# 18장 경계 해부학

아키텍처 경계 중에서 가장 단순하며 가장 혼한 형태는 물리적으로 엄격하게 구분되지 않는 형태

단일체를 제외한 대다수의 시스템은 한 가지 이상의 경계 전략을 사용

- 서비스
    
    물리적인 형태를 띠는 가장 강력한 경계는 바로 서비스
    
    서비스는 자신의 물리적 위치에 구애받지 않음
    
    서비스 경계를 지나는 통신은 함수 호줄에 비해 매우 느림
    
    저수준 서비스는 반드시 고수준 서비스에 ‘플러그인’되어야 함
    

대체로 한 시스템안에서도 통신이 빈번한 로컬 경계와 지연을 중요하게 고려해야 하는 경계가 혼합되어 있음

# 19장 정책과 수준

소프트웨어 시스템이란 정책을 기술한 것

- 고수준 정책
    
    저수준 정책에 비해 덜 빈번하게 변경되고, 보다 중요한 이유로 변경
    
- 저수준 정책
    
    입력과 출력에 가까이 위치한 정책은 더 빈번하게 변경되며，보다 긴급성을 요하며, 덜 중요한 이유 로 변경되는 경향
    

모든 소스 코드 의존성의 방향이 고수준 정책을 향할 수 있도록 정 책을 분리했다면 변경의 영향도를 줄일 수 있음

# 20장 업무규칙

업무 규칙은 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차

핵심 업무 규칙은 보통 데이터(핵심 업무 데이터)를 요구

- 엔티티
    
    컴퓨터 시스템 내부의 객체로서, 핵심 업무 데이터를 기반으로 동 작하는 일련의 조그만 핵심 업무 규칙을 구체화
    
    엔티티의 인터페이스는 핵심 업무 데이터를 기반으로 동작하는 핵심 업무 규칙을 구현한 함수들로 구성
    
- 유스케이스
    
     자동화된 시스템이 사용 되는 방법을 설명
    
    사용자가 제공해야 하는 입력, 사용자에게 보여줄 출력，그리고 해당 출력을 생성하기 위한 처리 단계를 기술
    
    애플리케이션에 특화된 업무 규칙을 설명, 사용자와 엔티티 사이의 상호작용을 규정
    

엔티티는 자신을 제어하는 유스케이스에 대해 아무것도 알지 못함

유스케이스는 단일 애플리케이션에 특화

엔티티는 수많은 다양한 애플리케 이션에서 사용될 수 있도록 일반화된 것

- 결론
    
    업무 규칙은 수익을 내고 비용을 줄이는 코드를 수반
    
    이상적으로는 업무 규칙을 표현하는 코드는 반드시 시스템의 심장부에 위치 해야 함
    
    덜 중요한 코드는 이 심장부에 플러그인되어야 함
    
    업무 규칙은 시스템에서 가장 독립적이며 가장 많이 재사용할 수 있는 코드
    

# 21장 소리치는 아키텍처

- 좋은 소프트웨어 아키텍처는 프레임워크, 데이터베이스，웹 서버，그리고 여타 개발 환경 문제나 도구에 대해서는 결정을 미룰 수 있도록 만듦
- 프레임워크는 열어 둬야 할 선택사항
- 아키텍처가 유스케이스를 최우선으로 한다면，그리고 프레임워크와는 적당 한 거리를 둔다면，프레임워크를 전혀 준비하지 않더라도 필요한 유스케이스 전부에 대해 단위 테스트를 할 수 있어야 함

# 22장 클린 아키텍처

- 아키텍처의 목표
    - 관심사의 분리
    - 소프트웨어를 계층으로 분리함으로써 관심사의 분리라는 목표를 달성
    - 각 아키텍처는 최소한 업무 규칙을 위한 계층 하나와，사용자와 시스템 인터페이스를 위한 또 다른 계층 하나를 반드시 포함
    - 모든 시스템이 다음과 같은 특징을 지니도록 만듦
        - 프레임워크 독립성
        - 테스트 용이성
        - UI 독립성
        - 데이터베이스 독립성
        - 모든 외부 에이전시에 대한 독립성
    - 의존성 규칙
        - 내부의 원에 속한 요소는 외부의 원에 속한 어떤것도 알지 못함
        - 외부의 원에 선언된 데이터 형식도 내부의 원에서 절대로 사용해서는 안 됨
    - 엔티티
        - 전사적인 핵심 업무 규칙을 캡슐화 함
        - 특정 애플리케이션에 무언가 변경이 필요하더라도 엔티티 계층에는 절대로 영향을 주어선 안 됨
    - 유스케이스
        - 애플리케이션에 특화된 업무 규칙을 포함
        - 유스케이스는 엔티티로 들어오고 나가는 데이터 흐름을 조정
        - 애플리케이션이 변경된다면 유스케이스가 영향을 받음
    - 인터페이스와 어댑터
        - 어댑터는 데이터를 유스케이스와 엔티티에게 가장 편리한 형식에서 데이터베이스나 웹 같은 외부 에이전시에게 가장 편리한 형식으로 변환
    - 프레임워크와 드라이버
        - 모든 세부사항이 위치하는 곳
    - 경계 횡단하기
        - 제어흐름은 컨트롤러에서 시작, 유스케이스를 지남, 프레젠터에서 실행되면서 마무리
        - 제어흐름과 의존성의 방향이 명백히 반대여야 하는 경우 대체로 의존성 역전 원칙을 사용하여 해결
        - 경계를 가로질러 데이터를 전달할 때 데이터는 항상 내부의 원에서 사용하기에 가장 편리한 형태를 가져야 함

# 23장 프레젠터와 험블객체

- 험블 객체 패턴
    
    테스트하기 어려운 행위와 테스트하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법으로 고안
    
- 프레젠터와 뷰
    - 프레젠터
        - 테스트하기 쉬운 객체
        - 애플리케이션으로부터 데이터를 받아 화면에 표현할 수 있는 포맷으로 만드는 것
    - 뷰
        - 데이터를 화면으로 전달하는 간단한 일만 처리
- 데이터베이스 게이트웨이
    - 유스케이스 인터렉터와 데이터베이스 사이에 위치
    - 다형적 인터페이스로 애플리케이션이 데이터베이스에 수행하는 CRUD 작업과 관련된 모든 메서드 포함
- 결론
    
    아키텍처 경계에서 험플객체 패턴 사용시 전체 시스템의 테스트 용이성을 높일 수 있음
    

# 24장 부분적 경계

- 부분적 경계를 생성하는 방법 하나는 독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업은 모두 수행한 후，단일 컴포넌트에 그대로 모아만 두는 것
- 이 모두를 단일 컴포넌트로 컴파일해서 배포
- 퍼사드
    - Facade 클래스에는 모든 서비스 클래스를 메서드 형태로 정의하고，서비스 호출이 발생하면 해당 서비스 클래스로 호출을 전달
    - 클라이언트는 이들 서비스 클래스에 직접 접근할 수 없음
- 결론
    - 아키텍처 경계가 언제，어디에 존재해야 할지, 그리고 그 경계를 완벽하게 구현할지 아니면 부분적으로 구현할지를 결정하는 일 또한 아키텍트의 역할

# 25장 계층과 경계

- 우리는 아키텍처 경계가 언제 필요한지를 신중하게 파악해내야 함
- 이러한 경계가 무시되었다면 나중에 다시 추가하는 비용이 크다는 사실도 알아야 함
- 추상화가 필요하리라고 미리 예측해서는 안 됨
    
    ⇒ 오버 엔지니어링이 언더 엔지니어링보다 나쁠 때가 훨씬 많기 때문
    
- 경계가 필요할 수도 있는 부분에 주목하고，경계가 존재하지 않아 생기는 마찰의 어렴풋한 첫 조짐을 신중하게 관찰해야 힘
- 첫조짐이 보이는 시점이 되면, 해당 경계를구현하는 비용과무시할 때 감수할 비용을 가늠해야함

# 26장 메인 컴포넌트

- 메인 컴포넌트
    - 나머지 컴포넌트를 생성, 조정, 관리
    - 궁극적인 세부사항으로 가장 낮은 수준의 정책
    - 시스템의 초기 진입점
    - 모든 팩토리, 전략, 시스템 전반을 담당하는 나머지 기반 설비를 생성한 후，시스템에서 더 높은 수준을 담당하 는 부분으로 제어권을 넘기는 역할
    - 메인은 클린 아키텍처에서 가장 바깥 원에 위치하는 지저분한 저수준 모듈
    - 메인은 고수준의 시스템을 위한 모든 것을 로드한 후, 제어권을 고수준의 시스템에게 넘김
    - 메인은 플러그인이므로 메인 컴포넌트를 애플리케이션의 설정별로 하나씩 두도록 하여 둘 이상의 메인 컴포넌트를 만들 수도 있음

# 27장 크고작은 모든 서비스들

- 시스템의 아키텍처는 의존성 규칙을 준수하며 고수준의 정책을 저수준의 세부사항으로부터 분리하는 경계에 의해 정의
- 서비스라고 해서 항상 독립적으로 개발, 배포, 운영할 수 있는 것은 아님
- 컴포넌트 기반 서비스
    - 파생 클래스를 만드는 방식으로 신규 기능 추가
- 횡단 관심사
    - 아키텍처 경계가 서비스 사이에 있지 않다는 사실
    - 오히려 서비스를 관통하며, 서비스를 컴포넌트 단위로 분리
    - 아키텍처 경계를 정의하는 것은 서비스 내에 위치한 컴포넌트
- 결론
    - 서비스는 시스템의 확장성과 개발 가능성 측면에서 유용 but, 그 자체로는 아키텍처적으로 그리 중요한 요소는 아님
    - 시스템의 아키텍처는 시스템 내부에 그어진 경계와 경계를 넘나드는 의존성에 의해 정의
    - 시스템의 구성 요소가 통신하고 실행되는 물리적인 메커니즘에 의해 아키텍처가 정의되는 것이 아님

# 28장 테스트 경계

- 테스트는 시스템의 일부, 아키텍처에도 관여
- 테스트는 태생적으로 의존성 규칙을 따름
- 시스템 내부의 어떤 것도 테스트에는 의존하지 않음
- 테스트는 시스템의 컴포넌트를 향해，항상 원의 안쪽으로 의존
- 테스트는 독립적으로 배포 가능
- 테스트는 시스템 컴포넌트 중에서 가장 고립
- 테스트의 역할은 운영이 아니라 개발을 지원하는 데 있음
- 테스트가 시스템의 설계와 잘 통합되지 않으면, 테스트는 깨지기 쉬워지고，시스템은 뻣뻣해져서 변경하기가 어려워짐
- 시스템에 강하게 결합된 테스트라면 시스템이 변경될 때 함께 변경되어야 함
- 테스트 API
    - 테스트가 모든 업무 규칙을 검증하는 데 사용할 수 있 도록 특화된 API를 만들면 됨
    - 테스트 API는 테스트를 애플리케이션으로부터 분리할 목적으로 사용
    - 테스트 API의 역할은 애플리케이션의 구조를 테스트로부터 숨기는 데 있음
    - 이렇게 만들면 상용 코드를 리팩터링하거나 진화시키더라도 테스트에는 전혀 영향을 주지 않음
    - 또한 테스트를 리팩터 링하거나 진화시킬 때도 상용 코드에는 전혀 영향을 주지 않음
    - 테스트 API 자체와 테스트 API 중 위험한 부분의 구현부는 독립적으로 배포할 수 있는 컴포넌트로 분리해야 함

# 29장 클린 임베디드 아키텍처

- 소프트웨어는 긴 시간 유용하게 쓸 수 있음
- 펌웨어는 하드웨어가 발전 할수록 낡아 갈 것
- 앱티튜드 테스트
    - 앱이 동작하도록 만드는 것
    - 이것을 통과했다고 이 애플리케이션이 클린 임베디드 아키텍처를 가진다고 말하기는 어려움
- 타깃-하드웨어 병목현상
    - 임베디드 코드가 클린 아키텍처 원칙과 실천법을 따르지않고 작성된다면,대개의 경우 코드를 테스트할수 있는환경이 해당 특정 타깃으로 국한될 것
    - 그 타깃이 테스트가 가능한 유일한 장소라면 타깃-하드웨어 병목현상이 발생
    - HAL
        - 소프트웨어와 펌웨어 사이의 경계
        - 자신보다 위에 있는 소프트웨어를 위해 존재
        - HAL의 API는 소프트웨어의 필요에 맞게 만들어져야 함
        - HAL은 타깃에 상관없이 테스트할 수 있는 경계층 또는 일련의 대체 지점을 제공
- 계층형 아키텍처는 인터페이스를 통해 프로그래밍하자는 발상을 기반으로 함
- 모듈들이 서로 인터페이스를 통해 상호작용한다면 특정 서비스 제공자를 다른 제공자로 대체할 수 있음
- 결론
    - 펌웨어가 되도록 내버려두면 제품이 오래 살아남을 수 없게 됨
    - 오직 타깃 하드웨어에서만 테스트할 수 있는 제품도 마찬가지
