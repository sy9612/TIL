# 30장 데이터베이스는 세부사항이다

- 데이터베이스는 세부사항이라서 아키텍처의 구성요소 수준으로 끌어올릴 수 없음
- 관계형 테이블은 특정한 형식의 데이터에 접근하는 경우에는 편리
    
     데이터를 테이블에 행 단위로 배치한다는 자체는 아키텍처적으로 볼 때 전혀 중요하지 않음
    
    애플리케이션의 유스케이스는 이러한 방식을 알아서는 안 되며 관여해서도 안 됨
    
- 디스크 때문에 피해갈 수 없는 시간 지연이라는 짐을 완화하기 위해，색인, 캐시，쿼리 계획 최적화가 필요
- 파일 시스템은 문서documem 기반
    
    문서를 이름을 기준으로 저장하거나 조회할 때는 잘 동작
    
    내용을 기준으로 검색할 때는 그리 크게 도움되지 않음
    
- 데이터베이스 시스템은 내용 기반
    
    데이터 베이스 시스템은 내용을 기반으로 레코드를 자연스럽고 편리하게 찾는 방법을 제공
    
    정형화되지 않은 문서를 저장하고 검색하는 데는 대체로 부적합
    
- 데이터베이스는 그저 메커니즘에 불과, 데이터가 어떤 형태인지는 절대로 신경 써서는 안 됨

# 31장 웹은 세부사항이다

GUI는 세부사항이며 웹은 GUI, 따라서 웹은 세부 사항임

아키텍트라면 이러한 세부사항을 핵심 업무 로직에서 분리된 경계 바깥에 두어야 함

# 32장 프레임워크는 세부사항이다

- 프레임워크 제작자 입장
    
    프레임워크와의 결합이 위험 요소가 되지 않음
    
    오히려 프레임워크와 결합되기를 바람
    
- 프레임워크는 의존성 규칙을 위반하는 경향이 있음
- 프레임워크는 애플리케이션의 초기 기능을 만드는 데는 도움이 될 것
    
    하지만 제품이 성숙해지면서 프레임워크가 제공하는 기능과 틀을 벗어나게 될 것
    
- 해결책
    - 프레임워크는 아키텍처의 바깥쪽 원에 속하는 세부 사항으로 취급
    - 프락시를 만들고 업무 규칙에 플러그인할 수 있는 컴포넌트에 이들 프락시를 위치
    - 프레임워크가 핵심 코드 안으로 들어오지 못하게 함

# 33장 사례 연구 : 비디오 판매

- 시스템의 초기 아키텍처를 결정하는 첫 단계는 액터와 유스케이스를 식별 하는 일
- 추상 유스케이스는 범용적인 정책을 담고 있으며，다른 유스케이스에서 이를 더 구체화 함
- 추상 유스케이스를 다이어그램에서 없애더라도 전체 제품의 기능을 조금도 손상시키지 않음

# 34장 빠져 있는 창

- 계층 기반 패키지
    - 가장 단순한 첫 번째 설계 방식은 전통적인 수평 계층형 아키텍처
    - 기술적인 관점에서 해당 코드가 하는 일에 기반해 그 코드를 분할함
    - 엄격한 계층형 아키텍처’의 경우 계층은 반드시 바로 아래 계층에만 의존
    - 이 아키텍처는 엄청난 복잡함을 겪지 않고도 무언가를 작동시켜 주는 아주 빠른 방법
    - 단점
        - 소프트웨어가 커지고 복잡해지기 시작하면 더 잘게 모듈화 해야할지를 고민해야 함
        - 계층형 아키텍처는 업무 도메인에 대 해 무것도 말해주지 않는다는 문제
- 기능 기반 패키지
    - 서로 연관된 기능，도메인 개념, 또는 Aggregate Root에 기반하여 수직의 얇은 조각으로 코드를 나누는 방식
- 포트와 어댑터
    - 업무/도메인에 초점을 둔 코드가 프레임워크나 데이터베이스 같은 기술적
    인 세부 구현과 독립적이며 분리된 아키텍처를 만들기 위함
    - ‘내부’ 영역은 도메인 개념을 모두 포함
    - ‘외부’ 영역은 외부 세계(예 를 들면 UI，데이터베이스，서드파티 통합)와의 상호작용을 포함
    - 도메인 주도 설계에서는 ‘내부’에 존재하는 모든 것의 이름은 반드시 ‘유비쿼터스 도메인 언어 관점에서 기술
- 컴포넌트 기반 패키지
    - 계층형 아키텍처의 경우 속임수를 써서 몇몇 의존성을 의도치 않은 방식으로 추가하더라도，보기에는 여전히 좋은 비순환 의존성 그래프가 생성됨
        
        ⇒ 완화된 계층형 아키텍처
        
    - 빌드시 정적 분석 도구를 사용해 아키텍처적인 위반사항 없는지 검사
    - 팀차원에서 정의한 아키텍처 위반시 위반 항목을 알려주고 빌드 실패시킴
        
        ⇒ 그 결과를 알게되는 주기가 필요이상으로 길다
        
    
    ⇒ 컴포넌트 기반 패키지 도입해야하는 이유
    
    - 큰 단위의 단일컴포넌트와 관련된 모든 책임을 하나의 자바 패키지로 묶음
    - 컴포넌트의 정의
        - 엉클 밥
            
            배포할 수 있는 가장 작은 단위
            
        - 저자
            
            컴포넌트는 멋지고 깔끔한 인터페이스로 감싸진 연관된 기능들의 묶음, 애플리케이션과 같은 실행환경 내부에 존재
            
    - 장점
        - 주문과 관련된 무언가를 코딩해야할 때 오직 한 곳만 둘러보면 됨
        - 컴포넌트 내부에서 관심사의 분리는 여전히 유효하며 업무로직은 데이터 영속성과 분리되어 있음
- 다른 결합 분리 모드
- 결론
    - 설계를 어떻게 해야만 원하는 코드 구조로 매핑할 수 있을지，그 코드를 어떻게 조직화할지，런타임과 컴파일타임에 어떤 결합 분리 모드를 적용할지 를 고민
    - 가능하다면 선택사항을 열어두되，실용주의적으로 행하기
    - 선택된 아키텍처 스타일을 강제하는 데 컴파일러의 도움을 받을 수 있을지를 고민
    - 데이터 모델과 같은 다른 영역에 결합되지 않도록 주의
