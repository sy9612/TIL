# 3부 설계 원칙

**단일 책임 원칙(SRP)**

함수는 반드시 단 하나의 일만 해야 한다는 원칙

컴포넌트 수준에서는 공통 폐쇄 원칙

아키텍처 수준에서는 경계의 생성을 책임지는 변경의 축

퍼사드 패턴 :  서브시스템에 있는 인터페이스들에 대한 통합된 인터페이스를 제공



**개방 폐쇄 원칙(OCP)**

소프트웨어 개체의 행위는 확장할 수 있어야 하지만 이때 개체를 변경해서는 안 됨

SRP원칙과 DIP원칙을 따라 변경량을 최소화 해야함

의존성 역전 원칙(DIP) : 요소 사이의 의존성을 체계화

책임을 분리하여 하나에서 변경이 발생해도 다른 하나는 변경되지 않도록 소스코드 의존성을 확실히 조직화

행위가 확장될 때 변경이 발생하지 않음을 보장해야 함

아키텍트는 기능이 어떻게, 왜 , 언제 발생하는지에 따라 기능을 분리

분리한 기능을 컴포너트의 계층구조로 조직화

시스템을 컴포넌트 단위로 분리, 의존성 계층구조를 만들어야 함



**리스코프 치환 원칙(LSP)**

상위 타입의 객체를 하위 타입의 객체로 **치환**해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 함



**인터페이스 분리 원칙(ISP)**

클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 **원칙**

큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리시킴으로써 클라이언트들이 꼭 필요한 메서드들만 이용할 수 있게 함

자바와 같은 **정적 타입 언어**는 사용자가 타입 선언문을 사용하도록 강제함

소스코드에 포함된 선언문으로 인해 소스코드 의존성이 발생, 재컴파일 재배포가 강제되는 상황이 초래

루비나 파이썬 같은 **동적 타입 언어**에선 존재하지 않음

=> ISP는 아키텍처가 아닌 언어와 관련된 문제



**의존성 역전 원칙(DIP)**

유연성 극대화된 시스템: 소스코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템

정적 타입 언어 : use, import, include 구문은 오직 인터페이스나 추상 클래스 같은 추상적인 선언만을 참조해야 함

동적 타입 언어 : 동일한 규칙 적용

DIP를 논할 때 운영체제나 플랫폼 같이 안정성이 보장된 환경에 대해선 무시

**안정된 소프트웨어 아키텍처**란 변동성이 큰 구현체에 의존X, 추상 인터페이스를 선호하는 아키텍처

변동성이 큰 구체 클래스를 참조X, 대신 추상 인터페이스를 참조

변동성이 큰 구체 클래스로부터 파생X

구체함수를 오버라이드X, 차라리 추상함수로 선언하고 구현체들에서 각자의 용도에 맞게 구현



# 4부 컴포넌트 원칙

빌딩에 방을 배치하는 방법을 설명

## **컴포넌트**

**컴포넌트란** 배포 단위

시스템의 구성 요소로 배포할 수 있는 가장 단위 

자바 - jar파일 / 루비 - gem파일 / 닷넷 - DLL

컴파일형 언어 :  바이너리 파일의 결합체

인터프리터형 언어 : 소스 파일의 결합체

여러 컴포넌트를 서로 묶어 .war파일로 만들 수 있음

컴포넌트는 반드시 독립적으로 배포, 개발 가능해야 함

**링커**

1. 링킹 로더의 등장으로 프로그램을 개별적으로 컴파일 로드할 수 있는 단위로 분할할 수 있게 됨

2. 프로그램이 커지자 링킹 로더가 느려짐

   링크와 로드를 분리

   링커라는 별도의 애플리케이션으로 링크 과정을 처리, 로더의 로딩 과정이 빨라짐

3. 프로그램이 더 커지자 전체 모듈 컴파일 시간이 길어짐

   디스크에 저장된 많은 데이터를 램에 캐싱하여 속도 증가

   프로그램 성장 속도보다 링크 시간이 줄어드는 속도가 빨라짐

4. 오늘 날엔 .jar 파일, DLL, 공유 라이브러리를 기존 애플리케이션에 플러그인 형태로 배포

소프트웨어 컴포넌트 : 런타임에 플러그인 형태로 결합할 수 있는 동적 링크파일



## **컴포넌트 응집도**

**재사용/릴리스 등가 원칙(REP)**

새로운 릴리스가 나오면 새 릴리스의 변경 사항을 살피고 기존 버전을 쓸지 결정

릴리스 절차에는 적절한. 공지와 릴리스 문서 작성도 포함해야 함

단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되야 함을 뜻함

단일 컴포넌트는 임의로 선택된 클래스와 모듈로 구성되어선 안 됨, 서로 공유하는 중요한 목적이 있어야 함

하나의 컴포넌트로 묶인 클래스와 모듈은 함께 릴리스 할 수 있어야 함



**공통 폐쇄 원칙(CCP)**

동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어야 함

단일 컴포넌트는 변경의 이유가 여러 개여서는 안 됨

 변경될 가능성이 있는 클래스는 모두 한곳으로 묶을 것을 권장

유지보수성 >>>> 재사용성



**공통 재사용 원칙(CRP)**

컴포넌트 사용자들을 필요하지 않는 것에 의존하게 하지말아야 함

개별 클래스가 단독으로 재사용되는 경우는 거의 없음, 이런 클래스들이 동일한 컴포넌트에 포함되어야 함을 의미

강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안 됨



1. REP와 CCP는 포함 원칙 2. CRP는 배제 원칙

REP와 CRP에 중점을 두면 사소한 변경 시 너무 많은 컴포넌트에 영향을 미침

REP와 CCP에 중점을 두면 불필요한 릴리스가 빈번해짐

프로젝트 초기엔 개발가능성 > 재사용성이기 때문에 CCP가 REP보다 중요

컴포넌트 구조는 시간과 성숙도에 따라 변함

어느 클래스들을 묶어 컴포넌트로 만들지를 결정할 때 재사용성과 개발가능성의 균형점을 맞추는게 중요



## **컴포넌트 결합**

숙취 증후군 : 많은 개발자가 동일한 소스파일을 수정하는 환경에서 발생

해결책

1. 주단위 빌드

중간 규모 플젝에서 사용

금요일이 되면 변경된 코드를 모두 통합하여 시스템 빌드

장점: 4일은 괜찮음

단점: 개발보다 통합에 드는 시간이 늘어나면서 팀 효율성 떨어짐

> =이거 완전 조삼모사 아닌가;;

2. 의존성 비순환 원칙(ADP)

개발 환경을 릴리스가 가능한 컴포넌트 단위로 분리

컴포넌트 사이의 의존성 구조를 관리해야 함, 순환이 없어 최초의 컴포넌트로 되돌아갈 수 없음



안정된 의존성 원칙(SDP)

설계는 결코 정적일 수 없음

공통폐쇄원칙을 준수함으로써 컴포넌트가 다른 유형의 변경에 영향을 받지 않으며 특정 유형의 변경만 가능하도록 만들 수 있음

변경이 쉽지 않은 컴포넌트가 변경이 예상되는 컴포넌트에 의존해선 안 됨

모든 컴포넌트가 안정적이어야 하는건 아님



안정된 추상화 원칙(SAP)

컴포넌트는 안정된 정도만큼만 추상화 되어야 함

안정성이 컴포넌트를 확장하는 일을 방해해서는 안 됨

안정적인 컴포넌트는 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 함

