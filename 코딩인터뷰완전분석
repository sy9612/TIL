# 자료구조

## 1. 배열과 문자열

1. 해시테이블
    
    효율적인 탐색을 위한 자료구조
    
    키를 값에 대응 시킴
    
    - 해시테이블 구현
        
        연결리스트와 해시 코드 함수 필요
        
        키와 값을 해시 테이블에 넣는 과정
        
        1. 키의 해시코드를 계산
            
            서로 다른 두 개의 키가 같은 해시 코드를 가르킬 수 있음
            
        2. 해시 코드를 이용해 배열의 인덱스를 계산
            
            서로 다른 두 개의 해시 코드가 같은 인덱스를 가르킬 수 있음
            
        3. 키에 상응하는 값 연결리스트에서 탐색
            
            배열의 각 인덱스엔 키와 값으로 이루어진 연결리스트가 존재
            
            키와 값을 해당 인덱스에 저장
            
            충돌1. 서로 다른 두 개의 키가 같은 해시코드를 가리키는 경우
            
            충돌2. 서로 다른 두 개의 해시코드가 같은 인덱스를 가리키는 경우
            
    - 충돌 자주 발생시 최악의 경우 수행시간 O(N)
        
        일반적으로 충돌 최소화로 탐색시간 O(1)
        
        균형 이진 탐색 트리 사용시 탐색시간 O(logN)
        
        - 크기가 큰 배열을 미리 할당 하지 않아도 됨, 작은 공간을 사용
        - 키의 집합을 특정 순서로 접근 가능
    - ArrayList 와 가변 크기 배열
        - ArrayList
            
            필요에 따라 크기 변환 가능
            
            O(1)의 접근 시간 유지
            
            배열이 가득 차는 순간 배열의 크기를 두 배로 늘림
            
            두배로 늘리는 시간 : O(N), 자주 발생하는 일은 아니라 상환 입력 시간으로 계산시 O(1)
            
    - StringBuilder
        
        가변 크기 배열을 이용해 필요한 경우에만 문자열을 복사하게끔 해줌
        

## 2. 연결리스트

차례로 연결된 노드를 표현해주는 자료구조

단방향과 양방향이 있음

배열과 달리 특정 인덱스를 상수 시간에 접근할 수 없음

K번째 원소를 찾고 싶다면 처음부터 K번 루프를 돌아야 함

1. 단방향에서 노드 삭제
    - 널 포인터 검사 반드시 해야함
    - 필요하면 head와 tail 포인터 갱신
    - 메모리 관리가 필요한 언어에선 메모리 반환 확인
2. Runner 기법
    - 연결리스트를 순회할 때 두 개의 포인터를 동시에 사용
3. 재귀 문제
    - 재귀 호출 깊이가 n이 될 경우 재귀 알고리즘이 적어도 O(n) 만큼의 공간을 사용

## 3. 스택과 큐

1. 스택
    - LIFO
    - pop(), push(), peek(), isEmpty()
    - 상수 시간에 i 번째 항목에 접근 불가
    - 데이터 추가나 삭제는 상수 시간에 가능
    - 같은 방향에서 아이템을 추가하고 삭제한다는 조건하에 연결 리스트로 구현 가능
    - 재귀 알고리즘 사용시 유용

1. 큐
    - FIFO
    - add(), remove(), peek(), isEmpty()
    - 연결리스트의 반대 방향에서 항목 추가, 제거 구현한다면 근본적으로 큐와 같음
    - 처음과 마지막 노드 갱신시 실수하지 않게 조심
    - BFS나 캐시 구현시 사용

## 4. 트리와 그래프

- 탐색하는 것이 선형 자료구조에 비해 까다로움
- 최악의 수행시간과 평균 수행 시간 매우 크게 바뀔 수 있음
- 트리는 노드로 이루어진 자료구조
- 하나의 루트 노드를 갖음
- 루트 노드는 0개 이상의 자식 노드를 갖고 있음
- 그 자식 노드 또한 0개 이상의 자식 노드를 갖고 있음
- 사이클이 존재할 수 없음
- 각 노드는 부모 노드로의 연결이 있을 수도 있고 없을 수도 있음
- 트리 vs 이진트리
    - 이진트리 : 각 노드가 최대 두 개의 자식을 갖는 트리
    - 말단 노드 : 자식이 없는 노드
- 이진트리 vs 이진 탐색 트리
    - 모든 노드가 다음과 같은 특정 순서를 따르는 속성이 있는 이진 트리
        
        모든 왼쪽 자식들 ≤ n < 모든 오른쪽 자식들
        
        위 조건은 내 밑에 있는 모든 자식 노드들에 대해 참이어야 함
        
        중복값을 처리하는 방식은 다를 수 있음, 면접관에게 명확히 얘기할 필요가 있음
        
- 균형 vs 비균형
    - 균형 트리
        
        균형을 잡는 것이 왼쪽과 오른쪽 크기를 완전히 같게 하는 것을 의미하진 않음
        
        - 레드-블랙 트리
        - AVL 트리
- 완전 이진트리
    
    트리의 모든 높이에서 노드가 꽉차 있는 이진 트리
    
    마지막 단계는 꽉 차 있지 않아도 되지만 노드가 왼쪽에서 오른쪽으로 채워져야 함
    
- 전 이진 트리
    
    모든 노드의 자식이 없거나 두 개 있는 경우
    
    자식이 하나만 있는 노드가 존재해서는 안 됨
    
- 포화 이진 트리
    
    전 이진 트리이면서 완전 이진 트리
    
    모든 밑단 노드는 같은 높이에 있어야 하며 마지막 단계에서 노드의 개수가 최대가 되어야 함
    
    노드의 개수가 정확히 2^k-1
    
- 이진 트리 순회
    - 중위 순회
        
        왼쪽, 현재, 오른쪽
        
    - 전위 순회
        
        현재, 왼쪽, 오른쪽
        
    - 후위 순회
        
        왼쪽, 오른쪽, 자신
        
- 이진 힙(최소힙과 최대힙)
    - 최소 힙
        
        트리의 마지막 단계에서 오른쪽 부분을 뺀 나머지 부분이 가득 채워져 있음
        
        완전 이진 트리
        
        각 노드의 원소가 자식들보다 작음
        
        루트는 트리 전체에서 가장 작은 원소
        
        - 삽입
            
            트리의 밑바닥에서부터 삽입 시작
            
            밑바닥 가장 오른쪽 위치로 삽입
            
            부모 노드와 교환해 나가며 제대로된 위치로 이동
            
            O(logn) 시간 걸림
            
        - 최소 원소 뽑아내기
            1. 최소 원소를 제거한 후 밑바닥 가장 왼쪽 원소와 교환
            2. 해당 노드를 최소합 성질 만족하도록 자식 노드와 교환해 나감
            3. O(logn) 시간 걸림
    - 최대 힙
        
        원소가 내림차순으로 정렬, 최소힙과 동일
        
- 트라이(접두사 트리)
    
    n차 트리의 변종
    
    각 노드에 문자를 저장하는 자료구조
    
    트리를 아래쪽으로 순회하면 단어 하나가 나옴
    
    *노드(널노드)는 단어의 끝을 나타냄
    
    접두사를 빠르게 찾아보기 위한 방식
    
    O(K) 시간에 해당 문자열이 유효한 접두사인지 확인 가능
    
- 그래프
    
    트리는 그래프의 한 종류
    
    모든 그래프가 트리는 아님
    
    트리는 사이클이 없는 하나의 연결 그래프
    
    노드와 그 노드를 연결하는 간선을 하나로 모아놓은 것
    
    여러 개의 고립된 부분 그래프로 구성될 수 있음
    
    모든 정점 쌍 간에 경로가 존재하는 그래프는 연결 그래프
    
    사이클이 존재할 수도 있고 존재하지 않을 수도 있음, 사이클이 없는 그래프는 비순환 그래프
    
- 그래프 탐색
    - DFS
        
        모든 노드를 방문하고자 할 때 선호
        
    - BFS
        
        두 노드 사이의 최단 경로 or 임의 경로 찾고 싶을 때
        
- 양방형 탐색
    
    출발지와 도착지 사이에 최단 경로를 찾을 때 사용
    
    출발지와 도착지 두 노드에서 동시에 BFS를 수행
    
    두 탐색 지점이 충돌하는 경우 경로를 찾음
    
    BFS보다 2배 더 긴 경로까지 찾을 수 있음
